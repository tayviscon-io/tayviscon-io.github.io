---
author: tyomych-tovkach
title: "Busy waiting: как избежать проблему?"
date: 2025-02-23 20:00:00 +0300
categories: [Статьи, "Лучшие практики"]
tags: []
description: Статья посвящена проблеме, известной как busy waiting. 
  Цель статьи - найти лучшее решение, чтобы избежать данную проблему.
---

> Перевод и адаптация статьи ["How To Avoid Busy Waiting"](https://josephmate.wordpress.com/2016/02/04/how-to-avoid-busy-waiting/).
{: .prompt-tip }
 
_В книге [Programming Interviews Exposed: Secrets to Landing Your Next Job](https://www.amazon.com/Programming-Interviews-Exposed-Secrets-Landing/dp/1118261364/ref=sr_1_1?ie=UTF8&qid=1454104897&sr=8-1&keywords=programming+interviews+exposed)
затрагивается тема **busy waiting**: в одном из вопросов нас просят рассказать о том,
что мы знаем про эту проблему и как её следует избегать.
В книге даже приводят решение данной проблемы, однако кажущееся не самым лучшим.
В рамках данной стати мы опишем проблему busy waiting и затем представим ряд решение, чтобы определить лучшее._

### Холостой цикл (или проблема busy waiting)

Мы можем себе представить ситуацию, когда один поток ждет результат от другого потока
и вы используете [NOOP](https://ru.wikipedia.org/wiki/NOP)/холостой цикл,
чтобы дождаться результата от потока - это и есть один из примеров проблемы, называемой _busy waiting_.
В качестве примера мы будем ожидать результата от двух подзадач, чтобы продемонстрировать данную проблему и её решение.

```java
Thread thread1 = new Thread(new Subtask1Runnable());
Thread thread2 = new Thread(new Subtask2Runnable());
thread1.start();
thread2.start();
while( waitinigForThread1() && waitingForThread2() ) {
  // холостой цикл
  }
// выполнение каких-либо действий с результатами из потоков thread1 и thread2
```

Такое решение точно следует избегать, так как у него очень высокая утилизация CPU:

1. Другие запущенные протоки могли бы использовать это процессорное время;
2. Другие процессы, работающие на той же машине, также могли бы использовать это процессорное время;
3. Если на машине только один процессор, thread2 мог бы использовать это процессорное время.

### Плохое решение: сон (sleep)

Итак, проблема вс том, что мы тратим CPU, чтобы многократно проверить условие,
но мы можем заставить поток немного поспать.

```java
while( waitinigForThread1() && waitingForThread2() ) {
    Thread.sleep(1000); // Поток спит 1 секунду
}
```

Это, конечно же, улучшение по сравнению с предыдущим вариантом,
потому что теперь мы тратим меньше процессорного времени.
Однако стоит учитывать, что у такого подхода есть все же некоторые недостатки:

1. Вы по-прежнему тратите процессорное время. 
Может показаться, что вы тратите один такт процессорного времени каждую секунду. Однако каждый раз,
когда поток просыпается, он должен перезагрузить стек потока, регистры и пересчитать, закончил ли другой поток.
Таким образом, у нас все еще есть существенные потери.
2. Как установить продолжительность сна?
   - Установите слишком большое значение - возникнет большая задержка между
   завершениями потоков подзадач и осознованием основным потоком того, что они завершены; 
   - Если установить слишком короткий интервал, вы увеличите количество холостых циклов.

### Улучшаем решение: экспоненциальный откат

Мы можем использовать подход, называемый "**Экспоненциальный откат**" (_Exponential Backoff_).
Для того чтобы лучше понять этот подход, представьте, что ваш самолет задерживается на какой-то неизвестный срок.
Что вы будете делать? Сначала вы можете сходить в туалет на несколько минут.
Затем вы можете перекусить в течении получаса.
Затем вы можете поиграть в игру на своем мобильном телефоне в течение часа.
И наконец, следующие пару часов вы будете читать книгу.
Задачи связанные с ожиданием, становятся все более масштабными по мере того, как вы ждете.
В этом и заключается идея экспоненциального отката. Вы спите все дольше, поскольку ждете все дольше.

```java
private static final int MAX_BACKOFF=1000*60*60; // 1 hour
private static final int INITIAL_BACKOFF=100; // 100ms
int backOff=INITIAL_BACKOFF;
while( waitinigForThread1() && waitingForThread2() ) {
    Thread.sleep(backOff); // Сначала поток спит 1 секунду
    backOff=backOff<<2; //Увеличение задержки в 4 раза
    if(backOff > MAX_BACKOFF) {
        backOff = MAX_BACKOFF;
    }
}
```

Это решение все ещё не идеальное и вот почему:
1. В идеале мы хотим, чтобы главный поток просыпался только один или два раза:
  - Один раз, когда завершается первая задача;
  - Второй раз, когда завершается вторая задача.
2. Нам все ещё нужно каким-то образом определять изначальные величины для _MAX_BACKOFF_ и _INITIAL_BACKOFF_,
чтобы обеспечить лучшую производительность.

### Достойное решение: блокировки или мониторы (на основе раскрытых интервью по программированию)

Как уже говорилось в предыдущем разделе, есть ли способ просто разбудить спящий поток после завершения каждой подзадачи?
Именно такое решение предлагают в книге _Programming Interview Exposed_.
Вы можете настроить установить блокировку и заставить главный поток ждать. Затем два потока "уведомляют",
когда они завершаться. Каждое "уведомление" пробуждает основной поток, и основной поток проверяет,
завершились ли оба потока.

Этот подход использует наименьшее количество процессорного времени,
но он может быть подвержен ошибкам из-за своей сложности. Если вы не напишете код должным образом,
вы можете столкнуться с условиями гонки или взаимной блокировки. Давайте рассмотрим наш пример с двумя подзадачами:

```java
Object lock = new Object(); // объект, используемый для синхронизации между потоками
int doneCount = 0;
Thread thread1 = new Thread(new Runnable() {
  public void run() {
    // ...
    // Выполнение первой подзадачи
    // ...
    synchronized(lock) {
      doneCount++;
      lock.notify();
    }
  }
});
Thread thread2 = new Thread(new Runnable() {
  public void run() {
    // ...
    // Выполнение второй подзадачи
    // ...
    synchronized(lock) {
      doneCount++;
      lock.notify();
    }
  }
});

// Основной поток
synchronized(lock) {
  thread1.start();
    thread2.start();
 
    while(doneCount < 2) {
  lock.wait();
    }
      }
```

Это решение весьма хорошее, потому что основной поток просыпается только дважды.
Один раз, когда завершается подзадача 1, и второй раз, когда завершается подзадача 2.

Однако при таком подходе мы можем ошибиться в ряде случаев:

1. Если бы мы запустили потоки вне синхронизированного блока, эти два потока могли бы завершиться до того,
как главный поток вызовет `wait()`;
В результате чего главный поток будет спать вечно и никакие уведомления в будущем не будут вызваны.
2. Если бы мы поместили счетчик вне синхронизированного блока, то два потока могли бы обновить его одновременно и 
мы бы получили значение _doneCount==1_ вместо **_2_**;
3. Если мы бы забыли вызвать `notify()` в одном из потоков, то главный поток так бы и не проснулся вовсе,
потому что не дополучил одно из уведомлений;
4. Размещение всей подзадачи в синхронизированный блок вместо простого доступа к общим данным позволило бы выполнять
только одну подзадачу за раз, что привело бы к отсутствию параллелизма;

В связи с этими особенностями решения, автор статьи не рекомендует его использовать.

### Хорошее решение: Futures и другие библиотеки параллелизма

Вместо того чтобы каждый раз пытаться тщательно кодировать этот паттерн, вы можете использовать библиотеки,
которые уже правильно реализовали эти паттерны.
В нашем примере, где мы ждем два результата от двух потоков, можно применить `Futures`.

```java
ExecutorService executor = ...
Future<String> future1 = executor.submit( new Callable<String>() {
    public String call() {
        /* Выполнение первой подзадачи */
    }
});
Future<String> future2 = executor.submit( new Callable<String>;() {
    public String call() {
        /* Выполнение второй подзадачи */
    }
} );
String result1 = future1.get();
String result2 = future2.get();
```

Из примера мы сразу видим, что это очень элегантное решение, которое в меньшей степени подвержено ошибкам.
Но что ещё важнее, мы все равно используем наименьшее количество процессорного времени,
поскольку выполнение основного потока возобновляется только после завершения каждого из `Future`.

### Заключение

Здесь мы рассмотрели пример ожидания завершения двух подзадач.
Однако существует множество различных сценариев ожидания,
а стандартная библиотека [Java](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html)
уже предоставляет множество возможностей параллелизма, облегчающих жизнь разработчикам.
Прежде чем пытаться кодировать собственный монитор или блокировку, посмотрите, была ли ваша проблема решена ранее.
