---
author: tyomych-tovkach
title: "Busy waiting: как избежать проблему?"
date: 2025-02-23 20:00:00 +0300
categories: [Статьи, "Лучшие практики"]
tags: []
description: Статья посвящена проблеме, известной как busy waiting. 
  Цель статьи - найти лучшее решение, чтобы избежать данную проблему.
---

> Перевод и адаптация статьи ["How To Avoid Busy Waiting"](https://josephmate.wordpress.com/2016/02/04/how-to-avoid-busy-waiting/).
{: .prompt-tip }
 
_В книге [Programming Interviews Exposed: Secrets to Landing Your Next Job](https://www.amazon.com/Programming-Interviews-Exposed-Secrets-Landing/dp/1118261364/ref=sr_1_1?ie=UTF8&qid=1454104897&sr=8-1&keywords=programming+interviews+exposed)
затрагивается тема **busy waiting**: в одном из вопросов нас просят рассказать о том,
что мы знаем про эту проблему и как её следует избегать.
В книге даже приводят решение данной проблемы, однако кажущееся не самым лучшим.
В рамках данной стати мы опишем проблему busy waiting и затем представим ряд решение, чтобы определить лучшее._

### Холостой цикл (или проблема busy waiting)

Мы можем себе представить ситуацию, когда один поток ждет результат от другого потока
и вы используете [NOOP](https://ru.wikipedia.org/wiki/NOP)/холостой цикл,
чтобы дождаться результата от потока - это и есть один из примеров проблемы, называемой _busy waiting_.
В качестве примера мы будем ожидать результата от двух подзадач, чтобы продемонстрировать данную проблему и её решение.

```java
Thread thread1 = new Thread(new Subtask1Runnable());
Thread thread2 = new Thread(new Subtask2Runnable());
thread1.start();
thread2.start();
while( waitinigForThread1() && waitingForThread2() ) {
  // холостой цикл
  }
// выполнение каких-либо действий с результатами из потоков thread1 и thread2
```

Такое решение точно следует избегать, так как у него очень высокая утилизация CPU:

1. Другие запущенные протоки могли бы использовать это процессорное время;
2. Другие процессы, работающие на той же машине, также могли бы использовать это процессорное время;
3. Если на машине только один процессор, thread2 мог бы использовать это процессорное время.

### Плохое решение: сон (sleep)

Итак, проблема вс том, что мы тратим CPU, чтобы многократно проверить условие,
но мы можем заставить поток немного поспать.

```java
while( waitinigForThread1() && waitingForThread2() ) {
    Thread.sleep(1000); // Поток спит 1 секунду
}
```

Это, конечно же, улучшение по сравнению с предыдущим вариантом,
потому что теперь мы тратим меньше процессорного времени.
Однако стоит учитывать, что у такого подхода есть все же некоторые недостатки:

1. Вы по-прежнему тратите процессорное время. 
Может показаться, что вы тратите один такт процессорного времени каждую секунду. Однако каждый раз,
когда поток просыпается, он должен перезагрузить стек потока, регистры и пересчитать, закончил ли другой поток.
Таким образом, у нас все еще есть существенные потери.
2. Как установить продолжительность сна?
   - Установите слишком большое значение - возникнет большая задержка между
   завершениями потоков подзадач и осознованием основным потоком того, что они завершены; 
   - Если установить слишком короткий интервал, вы увеличите количество холостых циклов.

### Улучшаем решение: экспоненциальный откат

Мы можем использовать подход, называемый "**Экспоненциальный откат**" (_Exponential Backoff_).
Для того чтобы лучше понять этот подход, представьте, что ваш самолет задерживается на какой-то неизвестный срок.
Что вы будете делать? Сначала вы можете сходить в туалет на несколько минут.
Затем вы можете перекусить в течении получаса.
Затем вы можете поиграть в игру на своем мобильном телефоне в течение часа.
И наконец, следующие пару часов вы будете читать книгу.
Задачи связанные с ожиданием, становятся все более масштабными по мере того, как вы ждете.
В этом и заключается идея экспоненциального отката. Вы спите все дольше, поскольку ждете все дольше.

```java
private static final int MAX_BACKOFF=1000*60*60; // 1 hour
private static final int INITIAL_BACKOFF=100; // 100ms
int backOff=INITIAL_BACKOFF;
while( waitinigForThread1() && waitingForThread2() ) {
    Thread.sleep(backOff); // Сначала поток спит 1 секунду
    backOff=backOff<<2; //Увеличение задержки в 4 раза
    if(backOff > MAX_BACKOFF) {
        backOff = MAX_BACKOFF;
    }
}
```

Это решение все ещё не идеальное и вот почему:
1. В идеале мы хотим, чтобы главный поток просыпался только один или два раза:
  - Один раз, когда завершается первая задача;
  - Второй раз, когда завершается вторая задача.
2. Нам все ещё нужно каким-то образом определять изначальные величины для _MAX_BACKOFF_ и _INITIAL_BACKOFF_,
чтобы обеспечить лучшую производительность.
